# Контрольные вопросы - ответы к Assignment 1

**1. В чём отличие динамического массива от статического массива в языке C++?**

- Статический массив: размер задаётся во время компиляции, память выделяется в стеке, и она освобождается автоматически при выходе из области видимости. Пример: `int arr[10];`
- Динамический массив: размер задаётся во время выполнения, память выделяется в куче с помощью new, и её нужно освобождать вручную с помощью `delete[]`. Пример: `int* arr = new int[n];`

**2. Что такое указатель и зачем он используется при работе с динамической памятью?**

Указатель - это переменная, которая хранит адрес другой переменной в памяти. Используется для:
- Доступа к динамически выделенной памяти.
- Передачи больших структур данных в функции без копирования.
- Организации сложных структур данных, например, списков, деревьев, графов.

**3. Почему важно корректно освобождать память после использования динамических массивов?**

Если не освобождать память, она остаётся занятой, что приводит к утечкам памяти. В больших или долгоживущих программах это может вызвать исчерпание ресурсов и падение программы.

**4. В чём разница между последовательной и параллельной обработкой массива?**

- Последовательная: операции выполняются одна за другой, только одним потоком.
- Параллельная: операции распределяются между несколькими потоками, которые работают одновременно.
Параллельная обработка может ускорять выполнение, особенно на больших массивах, но требует синхронизации и корректного доступа к данным.

**5. Что делает директива `#pragma omp parallel for`?**

- Создаёт параллельную область с несколькими потоками.
- Распараллеливает цикл for, распределяя итерации между потоками автоматически.
- Позволяет ускорять выполнение вычислений на многоядерных CPU.

**6. Для чего используется механизм `reduction` в OpenMP?**

`reduction` собирает результаты вычислений из разных потоков в одну переменную. Например, сумма элементов массива, минимальное или максимальное значение. Без reduction использование обычной переменной может привести к гонке потоков и некорректному результату.

**7. Почему при параллельном вычислении суммы необходимо использовать `reduction`, а не обычную переменную?**

Если несколько потоков одновременно будут писать в одну переменную, возникает condition race (гонка потоков). `reduction` создаёт локальные копии переменной для каждого потока, затем объединяет их безопасным способом, обеспечивая правильный результат.

**8. Какие факторы могут привести к тому, что параллельная версия программы будет работать медленнее последовательной?**

- Малый размер массива - накладные расходы на создание потоков и синхронизацию превышают выигрыш.
- Сложная синхронизация между потоками (например, частые критические секции).
- Неправильная организация данных в памяти (кэш-промахи).
- Несбалансированная нагрузка между потоками (одни потоки долго работают, другие ждут).
